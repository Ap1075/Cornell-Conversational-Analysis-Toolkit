from collections import defaultdict
import numpy as np
import scipy.stats

from convokit.transformer import Transformer
from typing import Dict, Optional
from convokit.model import Corpus, Utterance
from .hypergraph import Hypergraph

degree_stat_funcs = {
    "max": np.max,
    "argmax": np.argmax,
    "norm.max": lambda l: np.max(l) / np.sum(l),
    "2nd-largest": lambda l: np.partition(l, -2)[-2] if len(l) > 1 else np.nan,
    "2nd-argmax": lambda l: (-l).argsort()[1] if len(l) > 1 else np.nan,
    "norm.2nd-largest": lambda l: np.partition(l, -2)[-2] / np.sum(l) if len(l) > 1 else np.nan,
    "mean": np.mean,
    "mean-nonzero": lambda l: np.mean(l[l != 0]),
    "prop-nonzero": lambda l: np.mean(l != 0),
    "prop-multiple": lambda l: np.mean(l[l != 0] > 1),
    "entropy": scipy.stats.entropy,
    "2nd-largest / max": lambda l: np.partition(l, -2)[-2] / np.max(l) if len(l) > 1 else np.nan
}

motif_stat_funcs = {
    "is-present": lambda l: len(l) > 0,
    "count": len
}

class HyperConvo(Transformer):
    """
    Encapsulates computation of hypergraph features for a particular
    corpus.

    fit_transform() retrieves features from the corpus conversational
    threads using retrieve_feats, and stores it in the corpus's conversations'
    meta field under the key "hyperconvo"

    Either use the features directly, or use the other transformers, threadEmbedder (https://zissou.infosci.cornell.edu/socialkit/documentation/threadEmbedder.html)
    or communityEmbedder (https://zissou.infosci.cornell.edu/socialkit/documentation/communityEmbedder.html) to embed threads or communities respectively in a low-dimensional
    space for further analysis or visualization.

    As features, we compute the degree distribution statistics from Table 4 of
    http://www.cs.cornell.edu/~cristian/Patterns_of_participant_interactions.html,
    for both a whole conversation and its midthread, and for indegree and
    outdegree distributions of C->C, C->c and c->c edges, as in the paper.
    We also compute the presence and count of each motif type specified in Fig 2.
    However, we do not include features making use of reaction edges, due to our
    inability to release the Facebook data used in the paper (which reaction
    edges are most naturally suited for). In particular, we do not include edge
    distribution statistics from Table 4, as these rely on the presence of
    reaction edges. We hope to implement a more general version of these
    reaction features in an upcoming release.

    :param prefix_len: Length (in number of utterances) of each thread to
            consider when constructing its hypergraph
    :param min_thread_len: Only consider threads of at least this length
    :param include_root: True if root utterance should be included in the utterance thread,
                         False otherwise, i.e. thread begins from top level comment. (Affects prefix_len and min_thread_len counts.)
                         (If include_root is True, then each Conversation will have metadata for one thread, otherwise each Conversation
                         will have metadata for multiple threads - equal to the number of top-level comments.)
    """

    def __init__(self, prefix_len: int = 10, min_thread_len: int = 10, include_root: bool = True):
        self.prefix_len = prefix_len
        self.min_thread_len = min_thread_len
        self.include_root = include_root

    def transform(self, corpus: Corpus) -> Corpus:
        """
        Same as fit_transform()
        """
        return self.fit_transform(corpus)

    def fit_transform(self, corpus: Corpus, y=None) -> Corpus:
        """
        fit_transform() retrieves features from the corpus conversational
        threads using retrieve_feats()

        :param corpus: Corpus object to retrieve feature information from

        :return: corpus with conversations having a new meta field "hyperconvo" containing the stats generated by retrieve_feats(). Each conversation's metadata then contains the stats for the thread(s) it contains.
        """
        feats = HyperConvo.retrieve_feats(corpus)
        if self.include_root: # threads start at root (post)
            for root_id in feats.keys():
                convo = corpus.get_conversation(root_id)
                convo.add_meta("hyperconvo", {root_id: feats[root_id]})
        else: # threads start at top-level-comment
            # Construct top-level-comment to root mapping
            threads = corpus.utterance_threads(prefix_len=self.prefix_len, include_root=False)
            root_to_tlc = dict()
            for tlc_id, utts in threads.items():
                if len(utts) < self.min_thread_len: continue
                thread_root = threads[tlc_id][tlc_id].root
                if thread_root in root_to_tlc:
                    root_to_tlc[thread_root][tlc_id] = feats[tlc_id]
                else:
                    root_to_tlc[thread_root] = {tlc_id: feats[tlc_id]}

            for root_id in root_to_tlc:
                convo = corpus.get_conversation(root_id)
                convo.add_meta("hyperconvo", root_to_tlc[root_id])

        return corpus

    @staticmethod
    def _make_hypergraph(corpus: Optional[Corpus]=None,
                         utts: Optional[Dict[str, Utterance]]=None,
                         exclude_id: str=None) -> Hypergraph:
        """
        Construct a Hypergraph from all the utterances of a Corpus, or a specified subset of utterances

        :param corpus: A Corpus to extract utterances from
        :param utts: Subset of utterances to construct a Hypergraph from
        :param exclude_id: id of utterance to exclude from Hypergraph construction

        :return: Hypergraph object
        """
        if utts is None:
            if corpus is None:
                raise RuntimeError("fit_transform() helper method _make_hypergraph()"
                                   "has no valid corpus / utterances input")
            utts = {utt.id: utt for utt in corpus.iter_utterances()}

        G = Hypergraph()
        user_to_utt_ids = dict()
        reply_edges = []
        speaker_to_reply_tos = defaultdict(list)
        speaker_target_pairs = set()

        if exclude_id in utts:
            del utts[exclude_id]

        # nodes (utts)
        for utt in sorted(utts.values(), key=lambda h: h.timestamp):
            if utt.user not in user_to_utt_ids:
                user_to_utt_ids[utt.user] = set()
            user_to_utt_ids[utt.user].add(utt.id)
            if utt.reply_to is not None and utt.reply_to in utts:
                reply_edges.append((utt.id, utt.reply_to))
                speaker_to_reply_tos[utt.user].append(utt.reply_to)
                speaker_target_pairs.add((utt.user, utts[utt.reply_to].user, utt.timestamp))
            G.add_node(utt.id, info=utt.__dict__)

        # hypernodes (users)
        for user, ids in user_to_utt_ids.items():
            G.add_hypernode(user, ids, info=user.meta)

        # reply edges (utt to utt)
        for speaker_utt_id, target_utt_id in reply_edges:
            G.add_edge(speaker_utt_id, target_utt_id)

        # user to utterance response edges
        for user, reply_tos in speaker_to_reply_tos.items():
            for reply_to in reply_tos:
                G.add_edge(user, reply_to)

        # user to user response edges
        for user, target, timestamp in speaker_target_pairs:
            G.add_edge(user, target, {'timestamp': timestamp})

        return G

    @staticmethod
    def _node_type_name(b: bool) -> str:
        """
        Helper method to get node type name (C or c)

        :param b: Bool, where True indicates node is a Hypernode
        :return: "C" if True, "c" if False
        """
        return "C" if b else "c"

    @staticmethod
    def _degree_feats(utts: Optional[Dict[str, Utterance]] = None,
                      G: Optional[Hypergraph] = None,
                      name_ext: str = "",
                      exclude_id: Optional[str] = None) -> Dict:
        """
        Helper method for retrieve_feats().
        Generate statistics on degree-related features in a Hypergraph (G), or a Hypergraph
        constructed from provided utterances (uts)

        :param utts: utterances to construct Hypergraph from
        :param G: Hypergraph to calculate degree features statistics from
        :param name_ext: Suffix to append to feature name
        :param exclude_id: id of utterance to exclude from Hypergraph construction
        :return: A stats dictionary, i.e. a dictionary of feature names to feature values. For degree-related features specifically.
        """
        assert utts is None or G is None
        if G is None:
            G = HyperConvo._make_hypergraph(utts, exclude_id=exclude_id)

        stats = {}
        for from_hyper in [False, True]:
            for to_hyper in [False, True]:
                if not from_hyper and to_hyper: continue  # skip c -> C
                outdegrees = np.array(G.outdegrees(from_hyper, to_hyper))
                indegrees = np.array(G.indegrees(from_hyper, to_hyper))

                for stat, stat_func in degree_stat_funcs.items():
                    stats["{}[outdegree over {}->{} {}responses]".format(stat,
                                                                         HyperConvo._node_type_name(from_hyper),
                                                                         HyperConvo._node_type_name(to_hyper),
                                                                         name_ext)] = stat_func(outdegrees)
                    stats["{}[indegree over {}->{} {}responses]".format(stat,
                                                                        HyperConvo._node_type_name(from_hyper),
                                                                        HyperConvo._node_type_name(to_hyper),
                                                                        name_ext)] = stat_func(indegrees)
        return stats

    @staticmethod
    def _motif_feats(utts: Optional[Dict[str, Utterance]] = None,
                     G: Hypergraph = None,
                     name_ext: str = "",
                     exclude_id: str = None) -> Dict:
        """
        Helper method for retrieve_feats().
        Generate statistics on degree-related features in a Hypergraph (G), or a Hypergraph
        constructed from provided utterances (uts)

        :param utts: utterances to construct Hypergraph from
        :param G: Hypergraph to calculate degree features statistics from
        :param name_ext: Suffix to append to feature name
        :param exclude_id: id of utterance to exclude from Hypergraph construction
        :return: A dictionary from a thread root id to its stats dictionary, which is a dictionary from feature names to feature values. For motif-related features specifically.
        """
        assert utts is None or G is None
        if G is None:
            G = HyperConvo._make_hypergraph(utts=utts, exclude_id=exclude_id)



        stats = {}
        for motif, motif_func in [
            ("reciprocity motif", G.reciprocity_motifs),
            ("external reciprocity motif", G.external_reciprocity_motifs),
            ("dyadic interaction motif", G.dyadic_interaction_motifs),
            ("incoming triads", G.incoming_triad_motifs),
            ("outgoing triads", G.outgoing_triad_motifs)]:
            motifs = motif_func()
            for stat, stat_func in motif_stat_funcs.items():
                stats["{}[{}{}]".format(stat, motif, name_ext)] = \
                    stat_func(motifs)
        return stats

    def retrieve_feats(self, corpus: Corpus) -> Dict[str, Dict]:
        """
        Retrieve all hypergraph features for a given corpus (viewed as a set
        of conversation threads).

        See init() for further documentation.

        :return: A dictionary from a thread root id to its stats dictionary,
            which is a dictionary from feature names to feature values. For degree-related
            features specifically.
        """

        threads_stats = dict()

        for i, (root, thread) in enumerate(
                corpus.utterance_threads(prefix_len=self.prefix_len, include_root=self.include_root).items()):
            if len(thread) < self.min_thread_len: continue
            stats = {}
            G = HyperConvo._make_hypergraph(utts=thread)
            G_mid = HyperConvo._make_hypergraph(utts=thread, exclude_id=root)
            for k, v in HyperConvo._degree_feats(G=G).items(): stats[k] = v
            for k, v in HyperConvo._motif_feats(G=G).items(): stats[k] = v
            for k, v in HyperConvo._degree_feats(G=G_mid, name_ext="mid-thread ").items(): stats[k] = v
            for k, v in HyperConvo._motif_feats(G=G_mid, name_ext=" over mid-thread").items(): stats[k] = v
            threads_stats[root] = stats
        return threads_stats

